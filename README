
Project 4 :  Hash Overlap and Genome Assembly
==================================================

By Rohit Ramesh
----------------------------

    This project takes a series of disperate sequences and turns them into
a single valid genome. To do this we create hash overlap routine that
fits into the AMOS pipeline, and tells the tigger and consensus programs
where to look to find a set of reads that follow one another sequentially.

Structure
----------------------------

    So, this overlapper is a classic hash-overlap implementation, built 
from a few parts :

    * src/Project4.scala    : The program proper, contains all the code that
                              isn't particularly generic. The main function,
                              the various test and output modes, some defaults.

    * src/BioLibs.scala     : A Bioinformatics library, here you'll find various
                              aligners, kmer splitters, fasta and HOXD readers,
                              among other useful things. 

    * src/KmerTable.scala   : A special class deisgned to allow lots of kmers to
                              quickly stored and compared. The core data storage
                              class of this app.

    * src/ObjectStore.scala : A generic class to keep the build system from
                              being confused, and a number of smaller data storage
                              classes that don't amount to more that tuples with a
                              few utility functions tacked on.

    * Rakefile.rb           : The build autmation script, it lets me be much more
                              consice, and hide away the complexity of scala and 
                              java's command line interaction

    That's the higher order structure, underneath that there's a little 
pipeline of data transformations that takes place within the hash overlapper
itself. Now, thanks to configuration options, and scala's easy multithreading
there's a few layers at each level, but overall the whole things happens as
follows : 

    +------------------+
    +                  +    A simple little portion that reads a fasta file,
    +   Fasta Reader   +    and as each segment is read, it passes it either
    +                  +    synchronously, or asychronously to the Kmerer. 
    +------------------+
             |
             V
    +------------------+
    +                  +    The kmerer comes in one of two forms, a synchronous
    +      Kmerer      +    form, where each sequence is read sequentially and
    +                  +    sent to the KmerTable, or an asynchronous one where
    +------------------+    multiple sequences are being Kmered simultaneously
             |
             V  
    +------------------+
    +                  +    The Kmer table is a synchronous data structure that
    +    Kmer Table    +    will take the incoming kmers and sequence pairs, and
    +                  +    make a series of nice reverse/alternate lookup tables.
    +------------------+ 
             |
             V  
    +------------------+
    +                  +    This is a possibly synchronous/asynchronous section 
    + Align / Overlap  +    which takes sequence pairs and aligns and overlaps
    +                  +    them to get the final output. 
    +------------------+ 

    Each section is relatively simple but together they allow this app to quickly
align lots of sequences (not quite quickly enough, but that's for later). The 
multithreading allows for speed, and the modular design of the scaffold that holds
the aligner up lets us have many output modes and options for quick testing and
optimization.  

Tools
----------------------------

    The app comes with a large set of test modes and other useful output formats
in addition to the main .ovl output, I'll detail them in turn below.

    ### Overlap Calculator ###

    Command Line Flag : None or "--calc-overlaps"

    The standard output mode, takes a .seq file, and some options and prints a
standard .ovl file to STDOUT where you can channel or pipe it whereever. The 
output looks like the following. 

        ...

        {OVL
        adj:N
        rds:18,22
        scr:0
        ahg:20
        bhg:20
        }

        ...

    ### Fasta Read Tester ###

    Command Line Flag : "--test-fasta-read"

    Prints the first 10 or so sequences from the input to STDOUT, so it's easy 
to check if the fasta reader is working correctly. 

    ### Kmer Cover Tester ###

    Command Line Flag : "--test-kmer-cover"

    Will run through kmer sizes between 1 and 25 in your dataset and returns 
a count of uniques, and a measure of sequence collision totals.

    ### Collision Dispatch Tester ###

    Command Line Flag : "--test-dispatch-collisions"

    Gives a quick list of all sequence pairs that the overlapper wants to align
and shows warnings when sequences are dispatched more than once. 

    ### Block Dispatch Tester ###

    Command Line Flag : "--test-black-dispatch"

    Gives a list of all Single Sequence to Set of Sequences matches that the
overlapper wants to align, with some useful warnings for sequences that are
duplicated, and some useful statistics on sequence / kmer collisions.

    ### Alignment Tester ###

    Command Line Flag : "--test-alignment"

    Prints out the various information on each alignment done in an easily 
human readable format for quick verfication and testing. 

    ### Overlap Tester ###

    Command Line Flag : "--test-overlaps"

    Prints out a visualization of overlaps between sequences and various 
information in a human readable format for verfication and testing. 
 

Change of Language
----------------------------

    You'll noticed I switched languages from Java to Scala for this project.
I wanted to do it for project 3, but time constraints made me abandon that. 
I chose scala because it's got the speed benefits of java, can talk to the
BioJava libraries (though I haven't used them so far), and can multithread
much much more easily than Java. 

    Scala usually comes with a 15%-20% drop in speed compared to java, but 
with careful coding that can be reduced to nothing, with the ease of parrel-
elism that comes along with the switch, it's a net speed gain. 

    As for code reuse, Scala is similar enough to java that I could move over
my local alignment, fasta reader, and HOXD reader functions from project 3
mostly intact. They just lose all those ugly semicolons. 

Usage
----------------------------

    ### Clean Build ###

    To build from scratch run the following commands while in the same dir
as this readme file.

    $ rake clean
    $ rake build

    ### Running The Aligner ###

    This will create the default scala compatible jar file you can run 
directly with the following command:

    $ bin/scala Proj4Scala.jar -i <input-file>

    While there are command line options for everything, i'm too tired to
document them right now. Look in src/Project4.scala under the function
readArgs to see them all. In the meantime the above runs with the defaults
mentioned on piazza, with the HOXD matrix from project 3 hardcoded in. 

    ### Quick Run ###
    
    Will quickly run the aligner with the small sequence.

    $ rake run

    ### Pipeline Automation ###

    You can also run the full Amos or Project (my code) pipelines with the
following commands for the crp177 input, you'll find the output in /tmp. 
please be careful since running these commands will delete that folder and 
make you lose the input there. They also track timing information.

    $ rake pipeline:amos
    $ rake pipeline:project

    The same process with the large sequences can be run with the following.

    $ rake pipeline:amos:large
    $ rake pipeline:project:large

    At the moment this is a slow, but fully working solution, I plan to update
and improve it, but I'd liek to have *something* subbmitted at least for the 
moment. (Seriously, finals are an order of magnitude more stressful than I 
predicted, you'd think I'd have learned by now.) 

Optimal Settings
----------------------------

< To be taken care of later > 
